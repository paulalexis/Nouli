<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hamster Activity Tracker</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    body {
      font-family: 'Press Start 2P', cursive;
      background-color: black;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: 20px;
    }

    h1 {
      font-size: 32px;
      color: red;
      text-shadow: 2px 2px 4px rgba(255, 0, 0, 0.7);
    }

    /* Tabs container */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    /* Pixel-art tab buttons */
    .tab-button {
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      background-color: black;
      color: red;
      padding: 10px 15px;
      border: 4px solid red;
      box-shadow: 4px 4px 0px rgba(255, 0, 0, 0.7);
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
    }

    .tab-button:hover {
      transform: translate(-2px, -2px);
      box-shadow: 6px 6px 0px rgba(255, 0, 0, 0.7);
    }

    .tab-button.active {
      background-color: red;
      color: black;
      border-color: black;
    }

    /* Hide all containers by default */
    .container, .summary-container {
      display: none;
      gap: 20px;
      margin-top: 20px;
      width: 100%;
    }

    .active-tab {
      display: flex;
    }

    /* Styling for content containers */
    .info-container,
    .chart-container {
      flex: 1;
      height: 250px;
      background-color: black;
      border: 4px solid red;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 4px 4px 0px rgba(255, 0, 0, 0.7);
    }

    /* Info container (red background for contrast) */
    .info-container {
      background-color: red;
    }

    .info-container p {
      font-size: 14px;
      margin: 5px 0;
    }

    /* Ensuring charts scale properly without stretching */
    canvas {
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 100%;
    }

  </style>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
  <h1>Activity Tracker</h1>

  <!-- Tabs for switching between real-time data and night summary -->
  <div class="tabs">
    <button class="tab-button active" id="realTimeTab">Real-Time Data</button>
    <button class="tab-button" id="nightSummaryTab">Night Summary</button>
  </div>

  <!-- Real-time data and graph -->
  <div class="container active-tab" id="realTimeContainer">
    <div class="info-container">
      <p id="turnsDisplay">Turns: 0</p>
      <p id="speedDisplay">Speed: 0</p>
      <p id="time_turnDisplay">Time since last turn: 0</p>
    </div>

    <div class="chart-container">
      <canvas id="turnsChart"></canvas>
    </div>
  </div>

  <!-- Night summary section -->
  <div class="summary-container" id="nightSummaryContainer">
    <h2>Night Summary</h2>
    <div class="chart-container">
      <canvas id="activityHistogram"></canvas>
    </div>
  </div>    
  <script>
    // Initialize data for the turns chart (same as before)
    const data = {
      labels: [],  
      datasets: [{
        label: 'Total Turns Over Time',
        data: [],
        fill: false,
        borderColor: 'red',
        tension: 0,
        pointRadius: 0,
        pointBackgroundColor: 'red',
      }]
    };

    // Histogram Data (shows number of turns in intervals)
    const histogramData = {
      labels: [], 
      datasets: [{
        label: '',
        data: [],
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        borderColor: 'red',
        borderWidth: 1,
      }]
    };
  
    // Config for the total turns chart
    const turnsChartConfig = {
      type: 'line',
      data: data,
      options: {
        maintainAspectRatio: false,
        animation: false,
        plugins: {
          legend: {
            display: false
          },
        },
        responsive: true,
        scales: {
          x: {
            title: {
              display: true,
              text: 'Time',
              color: 'white',
            },
            ticks: {
              color: 'white',
            }
          },
          y: {
            title: {
              display: true,
              text: 'Total Turns',
              color: 'white',
            },
            ticks: {
              color: 'white',
            },
            beginAtZero: true
          }
        }
      }
    };
  
    // Config for the histogram chart
    const histogramChartConfig = {
      type: 'bar',
      data: histogramData,
      options: {
        maintainAspectRatio: false,
        animation: false,
        responsive: true,
        plugins: {
          legend: {
            display: false // This hides the legend
          }
        },
        scales: {
          x: {
            title: {
              display: true,
              text: `Time`,
              color: 'white',
            },
            ticks: {
              color: 'white',
            }
          },
          y: {
            title: {
              display: true,
              text: `Turns`,
              color: 'white',
            },
            ticks: {
              color: 'white',
              beginAtZero: true
            }
          }
        }
      }
    };

    const ctxTurns = document.getElementById('turnsChart').getContext('2d');
    const turnsChart = new Chart(ctxTurns, turnsChartConfig);

    const ctxHistogram = document.getElementById('activityHistogram').getContext('2d');
    const histogramChart = new Chart(ctxHistogram, histogramChartConfig);

    // Tab switching logic
    document.getElementById('realTimeTab').addEventListener('click', function() {
      document.getElementById('realTimeContainer').classList.add('active-tab');
      document.getElementById('nightSummaryContainer').classList.remove('active-tab');
      document.getElementById('realTimeTab').classList.add('active');
      document.getElementById('nightSummaryTab').classList.remove('active');
    });

    document.getElementById('nightSummaryTab').addEventListener('click', function() {
      document.getElementById('nightSummaryContainer').classList.add('active-tab');
      document.getElementById('realTimeContainer').classList.remove('active-tab');
      document.getElementById('nightSummaryTab').classList.add('active');
      document.getElementById('realTimeTab').classList.remove('active');
    });

    var intervalBase = 10;
    var turnInPreviousInterval = 0;

    function convertToTimeInSeconds(timestamp) {
      const date = new Date(timestamp);
      return date.getTime() / 1000;
    }

    // Fetch last 20 entries from the server when the page loads
    function loadLast20Entries() {
      fetch('/last_20_entries')
        .then(response => response.json())
        .then(dataResponse => {
          const entries = dataResponse.entries;

          // Convert entries into (turns, timestamp) array
          const timeTurnData = entries.map(entry => {
            return {
              turns: entry[1], // Number of turns
              timestamp: convertToTimeInSeconds(entry[0]) // Convert timestamp to seconds
            };
          });

          // Variable to track the current time (in seconds)
          let currentTime = Math.floor(Date.now() / 1000);

          // Array to store the turns at each 20-second interval
          let intervalData = [];
          let lastIndex = 0;

          // Iterate through 20-second intervals and capture the most recent data
          for (let i = 0; i <= 20; i++) {  // 60 intervals for example (can adjust as needed)
            const intervalStartTime = currentTime - 20 + i; // Start of the current 20-second interval

            // Find the most recent entry before or at the interval start time
            while (lastIndex < timeTurnData.length && timeTurnData[lastIndex].timestamp <= intervalStartTime) {
              lastIndex++;
            }

            // Get the corresponding number of turns for this interval
            if (lastIndex > 0) {
              const turns = timeTurnData[lastIndex - 1].turns;
              const timeString = new Date(intervalStartTime * 1000).toISOString().substr(11, 8); // Format: HH:MM:SS

              // Add to the chart data
              data.labels.push(timeString);
              data.datasets[0].data.push(turns);
            }
          }

          // Adjust Y-axis dynamically based on the data range
          const maxTurns = Math.max(...data.datasets[0].data);
          const minTurns = Math.min(...data.datasets[0].data);

          turnsChart.options.scales.y.max = maxTurns + 1;
          turnsChart.options.scales.y.min = minTurns - 1;
          turnsChart.update();  // Update the chart to show the fetched data

          lastEntry = timeTurnData[timeTurnData.length-1];

          document.getElementById('turnsDisplay').innerText = `Turns: ${lastEntry.turns}`;
          document.getElementById('speedDisplay').innerText = `Speed: ${lastEntry.speed} m/s`;
          document.getElementById('time_turnDisplay').innerText = `Time since last turn: ${lastEntry.time_turn} ms`;
        })
        .catch(error => console.error("Error fetching last 20 entries: ", error));
    }

    function loadHistogram() {
      fetch('/coHistogram')
        .then(response => response.json())
        .then(dataResponse => {
          const entries = dataResponse.data;

          // Process entries and add to the chart
          entries.forEach(entry => {
            const timeString = entry.time_start.substr(11, 8); // Extract HH:MM:SS from 'YYYY/MM/DD HH:MM:SS.SSS'
            histogramData.labels.push(timeString); // Add time label
            histogramData.datasets[0].data.push(entry.turns); // Add turns data
          });

          // Update the histogram chart
          histogramChart.update();

          turnInPreviousInterval = dataResponse.last_turns;

          console.log(turnInPreviousInterval );
          intervalBase = dataResponse.interval_size;
        })
        .catch(error => console.error("Error fetching Histogram entries: ", error));
    }

    
    // Function to track hamster's turns
    function trackTurns(turns) {
      const currentTime = new Date().toLocaleTimeString();
      const currentTimeDate = new Date();
      const uselessDate = new Date();
      
      const lastTurnHist = histogramData.datasets[0].data[histogramData.datasets[0].data.length - 1];
      const lastDateHist = histogramData.labels[histogramData.labels.length - 1];

      const [hours, minutes, seconds] = lastDateHist.split(':').map(Number);
      const lastDateHistDate = new Date(uselessDate.setHours(hours, minutes, seconds, 0));
      lastDateHistDate.setSeconds(lastDateHistDate.getSeconds() + intervalBase);

      if (lastDateHistDate > currentTimeDate){
        histogramData.datasets[0].data[histogramData.datasets[0].data.length - 1] += turns - turnInPreviousInterval;
      } else {
        histogramData.labels.push(lastDateHistDate.toLocaleTimeString([], { hour12: false }));
        histogramData.datasets[0].data.push(1);
        turnInPreviousInterval = turns - 1;
      }

      turnInPreviousInterval = turns;

      histogramChart.update();
  
      // Update turns chart with total turns (cumulative sum)
      data.labels.push(currentTime);
      data.datasets[0].data.push(turns);
  
      if (data.labels.length > 20) {
        data.labels.shift();
        data.datasets[0].data.shift();
      }
  
      // Dynamically adjust the Y-axis limits based on the data
      const maxTurns = Math.max(...data.datasets[0].data);
      const minTurns = Math.min(...data.datasets[0].data);
  
      turnsChart.options.scales.y.max = maxTurns + 1;
      turnsChart.options.scales.y.min = minTurns - 1;
      turnsChart.update();
    }

    // Function to fetch hamster data (turns)
    function fetchData() {
      fetch(`/data`)
        .then(response => response.json())
        .then(dataResponse => {
          document.getElementById('turnsDisplay').innerText = `Turns: ${dataResponse.turns}`;
          document.getElementById('speedDisplay').innerText = `Speed: ${dataResponse.speed} m/s`;
          document.getElementById('time_turnDisplay').innerText = `Time since last turn: ${dataResponse.time_turn} ms`;

          // Track the turns
          trackTurns(dataResponse.turns);
        })
        .catch(error => console.error("Error fetching data: ", error));
    }

    window.onload = function() {
      loadLast20Entries();
      loadHistogram();
      setInterval(fetchData, 1000);  // Update real-time data every second
    };
  </script>
</body>
</html>
